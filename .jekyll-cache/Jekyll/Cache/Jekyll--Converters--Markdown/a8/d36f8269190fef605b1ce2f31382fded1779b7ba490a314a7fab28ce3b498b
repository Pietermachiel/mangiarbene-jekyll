I"¬L<h4 id="talk-at-the-jekyllconf-2019">Talk at the JekyllConf 2019</h4>

<blockquote>
  <p>One of the best so called <strong>unconventional use cases of Jekyll</strong> is learning the basics of web development: HTML, CSS and JavaScript. At least in my case as a book designer with a non development background. But if the JavaScript part is growing in your application, you might be attempted to use React or other single page applications in JavaScript. Although it is not impossible to integrate React in Jekyll, it doesnâ€™t make much sense to use two website generators at the same time. Even aside from the issues in development you may encounter. Yet we donâ€™t have to say goodbye to Jekyll at this point at all.</p>
</blockquote>

<blockquote>
  <p>It is in fact very well possible to use Jekyll in creating API endpoints that can be consumed by other website generators. In this demo I will show the combination with React. That way you are completely free in your development, while enjoying the benefits of a simple, static and blog-aware Jekyll application. This time as a real backend.</p>
</blockquote>

<p><br /></p>

<h1 id="hello">Hello,</h1>

<div class="home-img_pieter">
    <img src="/public/img/pieter0.jpg" alt="" />   
</div>

<p><strong>â€¦my name is Pieter Roozen. I am a graphic designer based in The Hague, the Netherlands. I am the father of 4 and partner of Ruth. I love ski touring and sailing and I bake sourdough bread on a daily basis.</strong></p>

<p><br /></p>

<div class="home-img_vangogh">
    <img src="/public/img/studio.jpg" alt="" />   
</div>

<h2 id="studio-roozen">Studio Roozen</h2>

<p>Our design agency <strong>Studio Roozen</strong> specialized in designing books, art catalogues and museum concepts for Dutch museums. Among others, in full service for the <a href="https://roozen.nl/projecten/van-gogh-museum" target="_blank" rel="noopener noreferrer"><strong>Van Gogh Museum</strong></a> for more than 15 years. In 2015 I started working as a freelancer again. Of course the portfolio website of <a href="https://roozen.nl" target="_blank" rel="noopener noreferrer"><strong>Studio Roozen</strong></a> was made in Jekyll.</p>

<h2 id="jekyll-separates-content-from-logic">Jekyll separates content from logic</h2>

<p>The reason why I love Jekyll is because it has a very elegant manner of separating content from logic, including HTML. You can use Markdown to write coded content without writing HTML code yourself.</p>

<p>In fact I recognized that it functions similary to the way in â€˜the early daysâ€™, we would use text content written in Word in combination with QuarkXpress DTP software.</p>

<p>So it all feels very intuitive for an old school graphic designer, like me.</p>

<h2 id="restful-apis">Restful apiâ€™s</h2>

<p>These days, APIâ€™s to transfer data around the web are very popular. APIâ€™s are restful if you can do HTTP requests like GET, PUT, POST and DELETE, but in many cases you only need the GET request in order to present your content to the user.</p>

<p>Also content management frameworks like Drupal and even Wordpress, came with restful API solutions.</p>

<h2 id="how-about-jekyll">How about Jekyll?</h2>

<p>So how about Jekyll, as it is very good at separating content from the logic? And yes, it is in fact very well possible to create a JSON API endpoint with Jekyll!</p>

<p><strong>Basically, APIâ€™s are used to make the same content available to different applications in a form that can be parsed in the desired language.</strong></p>

<p>Typically, Jekyll is used because it is simple, safe, blog aware and fast. However, itâ€™s functionality is limited. Especially useful for presentational websites, blogs or even museum websites. Furthermore, obviously in Jekyll you can only use the GET method here because the application is static.</p>

<h2 id="perfect-match">Perfect match</h2>

<p>In fact, taken all together, this makes Jekyll a perfect match when we use itâ€™s content as API used in applications with more functionality, like React. Or what, if you have a limited amount of data and you need a fake API in a proof-of-concept (POC).</p>

<p>I know that there are different solutions out there to use fake online APIâ€™s for testing, like <a href="https://jsonplaceholder.typicode.com/" target="_blank" rel="noopener noreferrer"><strong>JSONplaceholder</strong></a>. But you still have to code your content and nobody likes doing that. With Jekyll, on the other hand, you can write content just like an editor.</p>

<p>But letâ€™s get started now.</p>

<h2 id="mangiarbene">MangiarBene</h2>

<p>For this demo I designed a simple Jekyll website about Cookbooks (what elseâ€¦? :-) called <strong>MangiarBene</strong>, dedicated to the famous Italian businessman and writer Pellegrino Artusi (1820â€“1911), and which in this case is the actual website you are visiting right now. It consists of two collections: one of <strong>15 cookbooks</strong> and another of <strong>48 recipes</strong> as well as a <strong>blog</strong> from which this actual post is the â€˜latestâ€™.</p>

<div class="home-img_websites">
    <img src="/public/img/jekyll.jpg" alt="" />
    <img src="/public/img/react.jpg" alt="" />
</div>

<p>You can go to the <a href="/">homepage</a> of <strong>MangiarBene</strong> now, if you want, and see how the website is structured.</p>

<p>Subsequently I developed a second SPA website (in React), that just uses the content from <strong>MangiarBene</strong> as JSON data. You could also examen this at <a href="https://api.roozen.nl" target="_blank" rel="noopener noreferrer">
https://api.roozen.nl
</a>. You will see that it is identical, only the background color is different.</p>

<p>The Jekyll website is hosted at CloudCannon and the React site is hosted at a Dutch hosting company.</p>

<p>But let me explain first.</p>

<h2 id="many-to-many-relationships">Many to many relationships</h2>

<p>In Jekyll it is possible to relate collections and posts from the content of the YAML front matter blocks. We can call the <strong>recipes</strong> and ad the book data to each recipe:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"book-links"</span><span class="nt">&gt;</span>
    {% for recipe in site.recipes %}
    {% if recipe.book == page.title %}
    <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"/recipes/{{ recipe.title | slugify }}"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;h5&gt;</span>{{ recipe.title }} {{ recipe.index }}<span class="nt">&lt;/h5&gt;</span>
    <span class="nt">&lt;/a&gt;</span>
    {% endif %}
    {% endfor %}    
<span class="nt">&lt;/div&gt;</span>
</code></pre></div></div>

<p>Likewise we can call the <strong>books</strong> and add the recipes that belong to a book:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"recipe-box_credits"</span><span class="nt">&gt;</span>
    {% for recipe in site.recipes %}
    {% if recipe.book == page.title %}
    <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"/recipes/{{ recipe.title | slugify }}"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;h5&gt;</span>{{ recipe.title }} {{ recipe.index }}<span class="nt">&lt;/h5&gt;</span>
    <span class="nt">&lt;/a&gt;</span>
    {% endif %}
    {% endfor %}   
<span class="nt">&lt;/div&gt;</span>
</code></pre></div></div>

<p>Both result in a data schema that is similar to the many-to-many-relationships used in databases. So what if in Jekyll we could use this technique to create a JSON file that contains the same structure, and make it available to the internet? And we sure can!</p>

<h2 id="constructing-the-api-endpoints">Constructing the API endpoints</h2>

<p>So we need JSON files. Well letâ€™s create them in Jekyll!</p>

<p>First we need a folder called <strong>api</strong> with files for <strong>books.json</strong> and <strong>recipes.json</strong>, so the url extension will result in <code class="highlighter-rouge">/api/books.json</code> and <code class="highlighter-rouge">/api/recipes.json</code>.</p>

<p>In the front matter block we just set the layout to null and thatâ€™s it. Now we can construct the JSON object and establish the same relations as we did before in creating the pages for books, recipes and posts.</p>

<h6 id="apibooksjson">/api/books.json</h6>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---
layout: null
---
[ 
  {% assign recipes = site.recipes | sort: "index" %}
  {% for recipe in recipes %}
      {
          "index": "{{ recipe.index }}",
          "title": "{{ recipe.title }}",
          "id": "{{ recipe.slugify }}",
          "product": "{{ recipe.product }}",
          "dish": "{{ recipe.dish }}",
          "url": "{{ recipe.url }}",
          "bookId"  : "{{ recipe.book | slugify }}",
          "bookTitle"  : "{{ recipe.book }}",          
          "page": "{{ recipe.page }}"
      },
]
</code></pre></div></div>

<p>There is only one problem here. The JSON object code block ends with a comma, so the last recipe ends also with a comma. JSON, however, disallows trailing commas. Now, in Liquid, you can eliminate the last comma, with the <strong>unless forloop.last</strong> statement.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>          "page": "{{ recipe.page }}"
      }{% unless forloop.last %},{% endunless %}{% endfor %}
]
</code></pre></div></div>

<h2 id="a-flat-json-tree">A flat JSON tree</h2>

<p>The form of JSON is very much dependent of the language in which the data is consumed. In the case of React the best advise is to keep the JSON tree as flat as possible. This pattern,  called <strong>denormalization</strong>, is well known in both relational and non-relational databases. In this case we would â€˜connectâ€™ the <strong>recipes</strong> data with the <strong>books</strong> data using a <strong>bookId</strong> instead of calling all the data of each book as nested in the <strong>recipes</strong> object.</p>

<h6 id="httpstrim-seahorsecloudventnetapirecipesjson">https://trim-seahorse.cloudvent.net/api/recipes.json</h6>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
[
    {
    index: "1",
    title: "Candied citrus peel",
    id: "candied-citrus-peel",
    product: "lemon",
    dish: "basics",
    url: "/recipes/candied-citrus-peel/",
    bookId: "30-ingredients",
    bookTitle: "30 ingredients",
    page: "160"
    },
...

</code></pre></div></div>

<h2 id="nested-structures">Nested structures</h2>

<p>With Jekyll we can establish every structure of JSON we want, also deeply nested ones.</p>

<p>In this case we have to do some more effort to get rid of the trailing comma in the last JSON object code block.</p>

<p>Since the if-statement works as a filter, and therefore not all iterations will become valid, a comma cannot be avoided here.</p>

<p>Let me explain.</p>

<p>Eliminating the last comma, with the <strong>unless forloop.last</strong> statement will not work here, in case the last iteration is not valid to the condition. In other words, the last iteration that is valid to the condition might not be the last of the forloop as a whole. Resulting in the last comma.</p>

<p>The solution is to use the push method to a fresh empty array, in order to create a new array with the desired content. This way we donâ€™t need the conditional statement anymore, because all iterations will be valid.</p>

<h6 id="apibooksjson-1">/api/books.json</h6>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---
layout: null
---
[ 
    {% for book in site.books %}
        {
            "title"    : "{{ book.title }}",
            "author"   : "{{ book.author }}",
            "publisher": "{{ book.publisher }}",
            "year"     : "{{ book.year }}",
            "kitchen"  : "{{ book.kitchen }}",
            "link"     : "{{ book.link }}",
            "book_url" : "{{ book.book_url }}",
            {% assign p = book.title | slugify %}
            {% assign my_recipe = "" | split: "" %}
            {% for recipetitle in site.recipes %}
            {% assign detitel = recipetitle.book | slugify %}
            {% if p == detitel %}
            {% assign itemtitle = "" | split: "" %}
            {% assign itemtitle = itemtitle | push: recipetitle %}
            {% assign my_recipe = my_recipe | push: itemtitle %}
            {% endif %}
            {% endfor %}
            "recipes"  : [ 
                {% for therecipe in my_recipe %}  
                {
                    "index"   : "{{ therecipe[0].index }}",
                    "title"   : "{{ therecipe[0].title }}",
                    "page"    : "{{ therecipe[0].page }}",
                    "product" : "{{ therecipe[0].product }}",
                    "dish"    : "{{ therecipe[0].dish }}"
                }{% unless forloop.last %},{% endunless %}
                {% endfor %}
            ],
            "text"  : "{{ book.text }}",
            "content"  : {{ book.content | jsonify }}
        }{% unless forloop.last %},{% endunless %}
    {% endfor %}
]
</code></pre></div></div>

<p>Finally we have to check if the JSON-file is valid at: 
<a href="https://jsonlint.com/" target="_blank" rel="noopener noreferrer">
https://jsonlint.com/
</a>.</p>

<h2 id="jekyll-as-a-blog-api">Jekyll as a blog API</h2>

<p>More interesting maybe is the fact that we can use the same technique to create a blog API from the Jekyll data. Now in the <strong>data</strong> folder create a file called blog.json, and follow the same instructions as before. Here we want to use the <strong>content</strong> of a post as well, while using Markdown text-to-HTML conversion, resulting in HTML tags in your output. Therefore you need to use the <strong>jsonify</strong> filter here. <code class="highlighter-rouge">{{ book.content | jsonify }}</code></p>

<h2 id="lets-take-it-to-the-next-level">Letâ€™s take it to the next level</h2>

<p>The blog API will grow over time and may at some point contain hundreds of blog posts. With respect to the API design in this demo, this might exceed the performance boundaries of JavaScript and the application might crash. What can we do?</p>

<p>Well, letâ€™s take this project to the next level!</p>

<p>The first step is to minimize the content of <code class="highlighter-rouge">/api/blog.json</code> at the <strong>MangiarBene</strong> app. Here, from each blog post object in fact we only need <code class="highlighter-rouge">post.title</code>, <code class="highlighter-rouge">post.category</code> and <code class="highlighter-rouge">post.date</code>. Doing so, we get rid of the huge text block in <code class="highlighter-rouge">post.content</code>. Next we need a solution for the individual pages of each blog post.</p>

<p>Now provide a folder <code class="highlighter-rouge">_writings</code> and copy the post files from the <code class="highlighter-rouge">_posts</code> folder. Here we need some refactoring. We donâ€™t need to call the date in the title anymore, and we should change the file extension to <code class="highlighter-rouge">.json</code>. In the <code class="highlighter-rouge">_config.yml</code> file we need to call the <code class="highlighter-rouge">_writings</code> collection and set the default layout like so:</p>

<h6 id="_configyml">_config.yml</h6>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>collections:
  writings:
    output: true
    permalink: /api/blog/:path.json

defaults:
  -
    scope:
      path: ""
      type: "writings"
    values:
      layout: layout-writings
</code></pre></div></div>

<p>Doing so, we will lose all the typical behavior of the post format in Jekyll, such as the date format and the support for categories and tags. But in the targeted JavaScript environment this would not work anyway. Also in JavaScript you can deal with these topics even more easy than in Jekyll :-).</p>

<h6 id="httpstrim-seahorsecloudventnetapiblogjekyll-api-endpoint-demojson">https://trim-seahorse.cloudvent.net/api/blog/jekyll-api-endpoint-demo.json</h6>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
index: "1",
title: "Jekyll API endpoint demo",
id: "jekyll-api-endpoint-demo",
date: "2019-08-21 00:00:00 +0000",
author: "Pieter Roozen",
category: "Development",
book: "",
source: "",
source_url: "",
content: "#### Talk at the Jekyll video conference 2019 &gt; One of the best
...
</code></pre></div></div>

<p>As you can see, in the content the Markdown tags are still existant, because in Jekyll only .md-files will convert them to valid HTML. But as I mentioned before, this can be done in React as well, see 
<a href="https://github.com/rexxars/react-markdown" target="_blank" rel="noopener noreferrer">
react-markdown
</a>.</p>

<h2 id="publishing-the-jekyll-site-on-cloudcannon">Publishing the Jekyll site on CloudCannon</h2>

<p>Now we can Publish the result on Github and Cloudcannon, which in this case I already did, obviously.</p>

<p>You will find the repositories on 
<a href="https://github.com/Pietermachiel" target="_blank" rel="noopener noreferrer">GitHub</a>.</p>

<p>Subsequently, we can use the created Jekyll API endpoints. As you can see they are part of this actual website.</p>

<p><a href="https://trim-seahorse.cloudvent.net/api/recipes.json" target="_blank" rel="noopener noreferrer">
/api/recipes.json
</a>
<br />
<a href="https://trim-seahorse.cloudvent.net/api/books.json" target="_blank" rel="noopener noreferrer">
/api/books.json
</a>
<br />
<a href="https://trim-seahorse.cloudvent.net/api/blog.json" target="_blank" rel="noopener noreferrer">
/api/blog.json
</a></p>

<h2 id="using-the-api-in-react">Using the API in React</h2>

<p>Hosting the Jekyll website â€“ which includes the API endpoints â€“ on either GitHub or CloudCannon makes it easy to change the content, and see how this is in sync with the SPA that consumes the content, in this demo developed in React:
<a href="https://api.roozen.nl" target="_blank" rel="noopener noreferrer">
https://api.roozen.nl
</a></p>

<h2 id="other-use-cases">Other use cases</h2>

<p>You could even use Jekyll to load a MongoDB database, which can be done by using a script in JavaScript and load different kinds of JSON files and structures at the same time or by just loading one JSON file directly. Here is a link to the documentation of <a href="https://docs.mongodb.com/manual/reference/program/mongoimport/" target="_blank" rel="noopener noreferrer">
MongoDB</a>.</p>

<h2 id="final-thoughts">Final thoughts</h2>

<p>If a collection of JSON objects is already available, you can use it in Jekyll as data, just like any other JSON of YAML file and produce the API endpoint from there.</p>

<p>And in order to respect the performance boundaries of JavaScript, as mentioned before, we could also think of pagination, indexation and search solutions.</p>

<p>Thatâ€™s all there is to it.</p>

<p>I hope my talk was inspiring for other developers. Let them wrap their minds around this item, to bring more beautiful solutions with Jekyll Api endpoints.</p>

<p>So now just use your imagination. There is lot more you can do with Jekyll, than with Jekyll on its own!</p>
:ET